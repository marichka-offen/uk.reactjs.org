---
id: faq-state
title: Стан компонента
permalink: docs/faq-state.html
layout: docs
category: FAQ
---

### Для чого потрібен метод `setState`? {#what-does-setstate-do}

Метод `setState()` призначає зміни об'єкта `стану (state)`. У відповідь на зміни стану компонент рендериться повторно.

### У чому полягає різниця між `state` та `props`? {#what-is-the-difference-between-state-and-props}

[`props (пропси)`](/docs/components-and-props.html) (скороч. від англ. "properties" — властивості) і [`state (стан)`](/docs/state-and-lifecycle.html) — це звичайні JavaScript-об'єкти. Хоча обидва містять інформацію, що впливає на результат рендерингу, існує одна істотна відмінність: `пропси` *передаються в* компонент (слугуючи параметрами функції), у той час як `стан` *знаходиться у* компоненті і керується з нього (подібно до оголошення змінних усередині функції).

Для подальшого ознайомлення з поняттями `пропсів` та `стану` рекомендуємо наступні статті:
* [Props vs State](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md)
* [ReactJS: Props vs. State](https://lucybain.com/blog/2016/react-state-vs-pros/)

### Чому `setState` видає невірне значення? {#why-is-setstate-giving-me-the-wrong-value}

У React, як `this.props`, так і `this.state` представляють уже *відрендерені* значення, наприклад, те що наразі знаходиться на екрані.

Виклик `setState` — асинхронний, тому не варто розраховувати, що `this.state` відобразить нове значення відразу ж  після виклику. Якщо вам потрібно розрахувати значення, засновані на поточному стані, замість об'єкта добавте функцію, яка спрацює після оновлення стану (детальну інформацію див. нижче).

Приклад коду, що *не* працюватиме належним чином:

```jsx
incrementCount() {
  // Примітка: код *не* працюватиме належним чином.
  this.setState({count: this.state.count + 1});
}

handleSomething() {
  // Припустимо, що `this.state.count` починається з 0.
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();
  // Коли React повторно відрендерить компонент, `this.state.count` буде дорівнювати 1 замість очікуваних 3.

  // Це відбувається тому, що функція `incrementCount()` вище бере своє значення зі `this.state.count`,
  // але React не оновить `this.state.count` доки компонент не відрендериться повторно.
  // Тож, кожного разу `incrementCount()` звертається до поточного значення `this.state.count` — 0 — і додає 1.

  // Нижче розглянемо як залагодити дану проблему!
}
```

Див. нижче як залагодити цю проблему!

### Як оновити значення, залежне від поточного стану? {#how-do-i-update-state-with-values-that-depend-on-the-current-state}

Замість об'єкта добавте до `setState` функцію, яка відповідатиме за оновлення значення стану (див. нижче).

### У чому полягає різниця між доданням об'єкта або функції у `setState`? {#what-is-the-difference-between-passing-an-object-or-a-function-in-setstate}

Додання функції оновлення надає доступ до поточного стану всередині самої функції. Оскільки `setState` виклики згруповані, це допомагає зв'язати зміни і гарантує, що вони виконуватимуться одна за одною без конфліктів:

```jsx
incrementCount() {
  this.setState((state) => {
    // Важливо: використовуйте `state` замість `this.state` при оновленні.
    return {count: state.count + 1}
  });
}

handleSomething() {
  // Припустимо, що `this.state.count` починається з 0.
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();

  // Значення `this.state.count` все ще дорівнює 0.
  // Але коли React повторно відрендерить компонент, значення дорівнюватиме 3.
}
```

[Дізнатись більше про setState](/docs/react-component.html#setstate)

### Коли `setState` працює асинхронно? {#when-is-setstate-asynchronous}

Наразі, `setState` працює асинхронно усередині обробника подій.

Це гарантує, наприклад, що якщо `Батьківський` та `Дочірній` компоненти викликають `setState` під час кліка, то `Дочірній` компонент не рендеритеметься двічі. Замість цього, React "відкладає" оновлення стану в кінець подій у браузері. Це допомагає значно підвищити продуктивність великих додатків.

Проте, безспосередньо на дану деталь реалізації покладатися не варто. У майбутніх версіях React за замовчуванням використовуватиме відкладені оновлення стану.

### Чому React не оновлює `this.state` синхронно? {#why-doesnt-react-update-thisstate-synchronously}

Як згадувалось раніше, перед початком повторного рендерингу React навмисно "очікує" доки всі компоненти викличуть `setState()` у своїх обробниках подій. Це дозволяє прискорити продуктивність уникаючи повторного рендерингу.  

У вас може виникнути питання, чому React просто відразу не оновить `this.state`.

Існує дві причини:

* Це порушить узгодженість між `props` та `state`, спричиняючи велику кількість помилок.

* Це зробить реалізацію нових властивостей неможливою.

У цьому [GitHub коментарії](https://github.com/facebook/react/issues/11527#issuecomment-360199710) дана тема розглядається глибше.

### Чи варто використовувати бібліотеки управління станом такі як Redux чи MobX? {#should-i-use-a-state-management-library-like-redux-or-mobx}

[Можливо.](https://redux.js.org/faq/general#when-should-i-use-redux)

Перед застосуванням додаткових бібліотек варто досконало вивчити React. Використовуючи тільки його можна створити досить комплексні додатки.
